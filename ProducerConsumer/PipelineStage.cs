using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace VGA.Tools.ProducerConsumer
{
    /// <summary>
    /// Represents a processing stage in the pipeline.
    /// </summary>
    /// <typeparam name="TInputType">The type taken as input by this stage.</typeparam>
    /// <typeparam name="TOutputType">The type of the output generated by this stage.</typeparam>
    public abstract class PipelineStage<TInputType, TOutputType> : IProcessingStage<TInputType, TOutputType>
    {
        #region Member declaration and initialization.

        protected IEnumerable<TInputType> mInputIterator;

        private Queue<TOutputType> mProcessedItems = new Queue<TOutputType>();
        private object mQueueLock = new object();
        protected int mPipelineDepth = 1;
        private bool mIsDone = false;
        private Semaphore mCompletionIndicator = new Semaphore(0,1);
        protected Semaphore mPipelineParallelismController = null;
        private IProcessingOutput<TInputType> mPrevious;
        protected string mName = string.Empty;
        private bool mIsParallel = false;
        private bool mOutputIteratorBlocked = true;

        public delegate void PipelineEventDelegate(IProcessingStage<TInputType,TOutputType> sender);
        public event PipelineEventDelegate Started;
        public event PipelineEventDelegate Completed;

        public delegate bool ValidationDelegate(TOutputType processedItem);
        public event ValidationDelegate ValidateProcessedItem;

        public delegate void OnProcessItemBegin(IProcessingStage<TInputType, TOutputType> sender, TInputType item);
        public event OnProcessItemBegin BeforeProcessSingleItem;

        public delegate void OnProcessItemCompleted(IProcessingStage<TInputType, TOutputType> sender, TInputType item, TOutputType processedItem);
        public event OnProcessItemCompleted AfterProcessSingleItem;

        #endregion

        #region Constructors

        /// <summary>
        /// Construct a pipeline stage.
        /// </summary>
        /// <param name="name">The name of the stage.</param>
        /// <param name="pipelineDepth">The maximum depth of the queue allowed in this stage.</param>
        /// <param name="previousStage">The previous stage from where this stage takes its input.</param>
        public PipelineStage(string name, int pipelineDepth, IProcessingOutput<TInputType> previousStage, bool isParallel)
        {
            mInputIterator = previousStage.GetOutput();
            mPipelineDepth = pipelineDepth;
            mPrevious = previousStage;
            mName = name;
            mIsParallel = isParallel;
            InitControllers();
        }

        /// <summary>
        /// Construct a pipeline stage.
        /// </summary>
        /// <param name="name">The name of the stage.</param>
        /// <param name="pipelineDepth">The maximum depth of the queue allowed in this stage.</param>
        /// <param name="inputIterator">The iterator to use to take input for this stage.</param>
        public PipelineStage(string name, int pipelineDepth, IEnumerable<TInputType> inputIterator, bool isParallel)
        {
            mInputIterator = inputIterator;
            mPipelineDepth = pipelineDepth;
            mPrevious = null;
            mName = name;
            mIsParallel = isParallel;
            InitControllers();
        }

        #endregion

        #region Public Properties

        public int Parallelism
        {
            get
            {
                return mPipelineDepth;
            }
        }

        public string Name
        {
            get
            {
                return mName;
            }
        }

        #endregion

        #region Methods

        public abstract TOutputType ProcessSingleItem(TInputType inputItem);

        /// <summary>
        /// This is the method where all processing will be done.
        /// The implementing class must iterate over the input of type <see cref="TInputType"/> and generate output 
        /// of type <see cref="TOutputType"/>
        /// </summary>
        public virtual void Start()
        {
            RaiseStartedEvent();
            foreach(TInputType item in mInputIterator)
            {
                ProcessItemInternal(item);
            }
            if(mIsParallel)
            {
                // Busy wait for threads to complete.
                int count1 = 0, count2 = 0, temp = 0;
                do
                {
                    ThreadPool.GetAvailableThreads(out count1, out temp);
                    ThreadPool.GetMaxThreads(out count2, out temp);
                    Thread.Sleep(250);
                } while (count1 != count2);
            }
            MarkDone();
            RaiseCompletedEvent();
        }

        /// <summary>
        /// Gets an enumerator to the output objects of type 
        /// <see cref="TOutputType"/> generated by this stage.
        /// </summary>
        /// <returns></returns>
        public virtual IEnumerable<TOutputType> GetOutput()
        {
            while (!mIsDone || mProcessedItems.Count > 0)
            {
                int queueLength = mProcessedItems.Count;
                if (queueLength > 0)
                {
                    TOutputType item = default(TOutputType);
                    lock (mQueueLock)
                    {
                        item = mProcessedItems.Dequeue();
                    }
                    if (!mIsDone && queueLength == 1)
                    {
                        mOutputIteratorBlocked = true;
                    }
                    yield return item;
                }
                if (mOutputIteratorBlocked)
                {
                    // Rest a bit before checking for queued items.
                    Thread.Sleep(250);
                    mOutputIteratorBlocked = false;
                }
            }
            yield break;
        }

        /// <summary>
        /// This call will block the calling thread, till execution of the pipeline stage is completed.
        /// </summary>
        public void WaitForCompletion()
        {
            mCompletionIndicator.WaitOne();
        }

        private void InitControllers()
        {
            if (mIsParallel)
            {
                mPipelineParallelismController = new Semaphore(mPipelineDepth, mPipelineDepth);
            }
        }

        private void RaiseStartedEvent()
        {
            if(this.Started != null)
            {
                Started(this);
            }
        }

        private void RaiseCompletedEvent()
        {
            if(this.Completed != null)
            {
                Completed(this);
            }
        }

        private void ProcessItemInternal(TInputType inputItem)
        {
            if (mIsParallel)
            {
                // Use the semaphore to maintain depth of the pipeline, when multi-threaded.
                // This will be released by ProcessItemWrapper.
                mPipelineParallelismController.WaitOne();
                ThreadPool.QueueUserWorkItem(new WaitCallback(ProcessItemWrapper), inputItem);
            }
            else
            {
                ProcessItemWrapper(inputItem);
            }
        }

        private void ProcessItemWrapper(object item)
        {
            TInputType inputItem = (TInputType)item;
            RaiseBeforeProcessSingleItem(inputItem);
            TOutputType result = ProcessSingleItem(inputItem);
            RaiseAfterProcessSingleItem(inputItem, result);
            if (mIsParallel)
            {
                mPipelineParallelismController.Release();
            }
            if (RaiseValidateProcessedItem(result))
            {
                lock (mQueueLock)
                {
                    AddItemToOutputQueue(result);
                }
            }
        }

        private bool RaiseValidateProcessedItem(TOutputType result)
        {
            if(ValidateProcessedItem != null)
            {
                return ValidateProcessedItem(result);
            }
            return true;
        }

        private void RaiseAfterProcessSingleItem(TInputType item, TOutputType result)
        {
            if(AfterProcessSingleItem != null)
            {
                AfterProcessSingleItem(this, item, result);
            }
        }

        private void RaiseBeforeProcessSingleItem(TInputType item)
        {
            if(BeforeProcessSingleItem != null)
            {
                BeforeProcessSingleItem(this, item);
            }
        }

        protected void MarkDone()
        {
            if (!mIsDone)
            {
                mCompletionIndicator.Release();
                mIsDone = true;
            }
        }

        protected void AddItemToOutputQueue(TOutputType item)
        {
            lock (mQueueLock)
            {
                mProcessedItems.Enqueue(item);
            }
            if (mOutputIteratorBlocked)
            {
                mOutputIteratorBlocked = false;
            }
        }

        public void SetInput(IEnumerable<TInputType> inputEnumerator)
        {
            mInputIterator = inputEnumerator;
        }

        #endregion
    }
}
