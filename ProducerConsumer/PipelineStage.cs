using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace VGA.Tools.ProducerConsumer
{
    /// <summary>
    /// Represents a processing stage in the pipeline.
    /// </summary>
    /// <typeparam name="TInputType">The type taken as input by this stage.</typeparam>
    /// <typeparam name="TOutputType">The type of the output generated by this stage.</typeparam>
    public abstract class PipelineStage<TInputType, TOutputType> : IProcessingStage<TInputType, TOutputType>
    {
        #region Member declaration and initialization.

        protected IEnumerable<TInputType> mInputIterator;

        private Queue<TOutputType> mProcessedItems = new Queue<TOutputType>();
        private object mQueueLock = new object();
        protected int mPipelineDepth = 1;
        private bool mIsProcessingDone = false;
        private Semaphore mPipelineParallelismController = null;
        private AutoResetEvent mProcessingCompletedSignal = new AutoResetEvent(false);
        private AutoResetEvent mCompletionEvent = new AutoResetEvent(false);
        private AutoResetEvent mOutputPipelineSignaller = new AutoResetEvent(true);
        private WaitHandle[] mCompletionHandle = null;
        protected string mName = string.Empty;
        private bool mIsParallel = false;
        private bool mOutputIteratorBlocked = true;
        private bool mShouldWaitForOutputQueue = true;
        private int mActiveThreadCount = 0;

        public delegate void PipelineEventDelegate(IProcessingStage<TInputType,TOutputType> sender);
        public event PipelineEventDelegate Started;
        public event PipelineEventDelegate Completed;

        public delegate bool ValidationDelegate(TOutputType processedItem);
        public event ValidationDelegate ValidateProcessedItem;

        public delegate void OnProcessItemBegin(IProcessingStage<TInputType, TOutputType> sender, TInputType item);
        public event OnProcessItemBegin BeforeProcessSingleItem;

        public delegate void OnProcessItemCompleted(IProcessingStage<TInputType, TOutputType> sender, TInputType item, TOutputType processedItem);
        public event OnProcessItemCompleted AfterProcessSingleItem;

        #endregion

        #region Constructors

        /// <summary>
        /// Construct a pipeline stage.
        /// </summary>
        /// <param name="name">The name of the stage.</param>
        /// <param name="pipelineDepth">The maximum depth of the queue allowed in this stage.</param>
        /// <param name="previousStage">The previous stage from where this stage takes its input.</param>
        /// <param name="isParallel">Set to true to use parallel threads in this stage.</param>
        public PipelineStage(string name, int pipelineDepth, IProcessingOutput<TInputType> previousStage, bool isParallel) :
            this(name, pipelineDepth, previousStage.GetOutput(), isParallel, true)
        {
        }

        /// <summary>
        /// Construct a pipeline stage.
        /// </summary>
        /// <param name="name">The name of the stage.</param>
        /// <param name="pipelineDepth">The maximum depth of the queue allowed in this stage.</param>
        /// <param name="previousStage">The previous stage from where this stage takes its input.</param>
        /// <param name="isParallel">Set to true to use parallel threads in this stage.</param>
        /// <param name="shouldWaitForOutputQueue">Set to false to indicate completion without waiting for the output queue to drain.</param>
        public PipelineStage(string name, int pipelineDepth, IProcessingOutput<TInputType> previousStage, bool isParallel, bool shouldWaitForOutputQueue):
            this(name, pipelineDepth, previousStage.GetOutput(), isParallel, shouldWaitForOutputQueue)
        {
        }

        /// <summary>
        /// Construct a pipeline stage.
        /// </summary>
        /// <param name="name">The name of the stage.</param>
        /// <param name="pipelineDepth">The maximum depth of the queue allowed in this stage.</param>
        /// <param name="inputIterator">The iterator to use to take input for this stage.</param>
        /// <param name="isParallel">Set to true to use parallel threads in this stage.</param>
        /// <param name="shouldWaitForOutputQueue">Set to false to indicate completion without waiting for the output queue to drain.</param>
        public PipelineStage(string name, int pipelineDepth, IEnumerable<TInputType> inputIterator, bool isParallel, bool shouldWaitForOutputQueue)
        {
            mInputIterator = inputIterator;
            mPipelineDepth = pipelineDepth;
            mName = name;
            mIsParallel = isParallel;
            mShouldWaitForOutputQueue = shouldWaitForOutputQueue;
            InitControllers();
        }

        #endregion

        #region Public Properties

        public int Parallelism
        {
            get
            {
                return mPipelineDepth;
            }
        }

        public string Name
        {
            get
            {
                return mName;
            }
        }

        #endregion

        #region Methods

        public abstract TOutputType ProcessSingleItem(TInputType inputItem);

        /// <summary>
        /// This is the method where all processing will be done.
        /// The implementing class must iterate over the input of type <see cref="TInputType"/> and generate output 
        /// of type <see cref="TOutputType"/>
        /// </summary>
        public virtual void Start()
        {
            RaiseStartedEvent();
            foreach(TInputType item in mInputIterator)
            {
                ProcessItemInternal(item);
            }
            WaitForWorkerThreads();
            // Unblock the output pipeline if it is blocked and let it run to completion.
            mOutputPipelineSignaller.Set();
            if(!mShouldWaitForOutputQueue)
            {
                mCompletionEvent.Set();
            }
            // If we are not waiting for the output pipeline to drain,
            // then this should already be signaled by the previous if block.
            WaitForCompletion();
            RaiseCompletedEvent();
        }

        private void WaitForWorkerThreads()
        {
            if (mIsParallel)
            {
                CheckAndSignalIfZero(mActiveThreadCount);
                WaitHandle.WaitAll(new WaitHandle[] { mProcessingCompletedSignal });
            }
            OnThreadsCompleted();
        }

        private void OnThreadsCompleted()
        {
            mIsProcessingDone = true;
        }

        /// <summary>
        /// Gets an enumerator to the output objects of type 
        /// <see cref="TOutputType"/> generated by this stage.
        /// </summary>
        /// <returns></returns>
        public virtual IEnumerable<TOutputType> GetOutput()
        {
            WaitHandle[] outputWaiterHandle = new WaitHandle[] { mOutputPipelineSignaller };
            while (!mIsProcessingDone || mProcessedItems.Count > 0)
            {
                int queueLength = mProcessedItems.Count;
                if (queueLength > 0)
                {
                    TOutputType item = default(TOutputType);
                    lock (mQueueLock)
                    {
                        item = mProcessedItems.Dequeue();
                    }
                    if (!mIsProcessingDone && queueLength == 1)
                    {
                        mOutputIteratorBlocked = true;
                        mOutputPipelineSignaller.Reset();
                        WaitHandle.WaitAll(outputWaiterHandle);
                    }
                    yield return item;
                }
            }
            if (mShouldWaitForOutputQueue)
            {
                mCompletionEvent.Set();
            }
            yield break;
        }

        /// <summary>
        /// This call will block the calling thread, till execution of the pipeline stage is completed.
        /// </summary>
        public void WaitForCompletion()
        {
            WaitHandle.WaitAll(mCompletionHandle);
        }

        private void InitControllers()
        {
            mCompletionHandle = new WaitHandle[] { mCompletionEvent };
            if (mIsParallel)
            {
                mPipelineParallelismController = new Semaphore(mPipelineDepth, mPipelineDepth);
            }
        }

        private void RaiseStartedEvent()
        {
            if(this.Started != null)
            {
                Started(this);
            }
        }

        private void RaiseCompletedEvent()
        {
            if(this.Completed != null)
            {
                Completed(this);
            }
        }

        private void ProcessItemInternal(TInputType inputItem)
        {
            if (mIsParallel)
            {
                // Use the semaphore to maintain depth of the pipeline, when multi-threaded.
                // This will be released by ProcessItemWrapper.
                mPipelineParallelismController.WaitOne();
                Interlocked.Increment(ref mActiveThreadCount);
                ThreadPool.QueueUserWorkItem(new WaitCallback(ProcessItemWrapper), inputItem);
            }
            else
            {
                ProcessItemWrapper(inputItem);
            }
        }

        private void ProcessItemWrapper(object item)
        {
            TInputType inputItem = (TInputType)item;
            RaiseBeforeProcessSingleItem(inputItem);
            TOutputType result = ProcessSingleItem(inputItem);
            RaiseAfterProcessSingleItem(inputItem, result);
            if (mIsParallel)
            {
                mPipelineParallelismController.Release();
                Interlocked.Decrement(ref mActiveThreadCount);
                CheckAndSignalIfZero(mActiveThreadCount);
            }
            if (RaiseValidateProcessedItem(result))
            {
                lock (mQueueLock)
                {
                    AddItemToOutputQueue(result);
                }
            }
        }

        private void CheckAndSignalIfZero(int threadCount)
        {
            if(threadCount == 0)
            {
                mProcessingCompletedSignal.Set();
            }
        }

        private bool RaiseValidateProcessedItem(TOutputType result)
        {
            if(ValidateProcessedItem != null)
            {
                return ValidateProcessedItem(result);
            }
            return true;
        }

        private void RaiseAfterProcessSingleItem(TInputType item, TOutputType result)
        {
            if(AfterProcessSingleItem != null)
            {
                AfterProcessSingleItem(this, item, result);
            }
        }

        private void RaiseBeforeProcessSingleItem(TInputType item)
        {
            if(BeforeProcessSingleItem != null)
            {
                BeforeProcessSingleItem(this, item);
            }
        }

        protected void AddItemToOutputQueue(TOutputType item)
        {
            lock (mQueueLock)
            {
                mProcessedItems.Enqueue(item);
            }
            mOutputPipelineSignaller.Set();
            if (mOutputIteratorBlocked)
            {
                mOutputIteratorBlocked = false;
            }
        }

        public void SetInput(IEnumerable<TInputType> inputEnumerator)
        {
            mInputIterator = inputEnumerator;
        }

        #endregion
    }
}
